/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

/* file generated by qcc, do not modify */

typedef struct globalvars_s
{
	int null;
	union {
		vec3_t vec;
		float f;
		int i;
	} ret;
	union {
		vec3_t vec;
		float f;
		int i;
	} param[8];
} globalvars_t;

#define	NUM_SPAWN_PARMS			64
typedef struct nqglobalvars_s
{
	int	*self;
	int	*other;
	int	*world;
	float	*time;
	float	*frametime;	
	int		*newmis;
	float	*force_retouch;
	string_t	*mapname;
	float	*deathmatch;
	float	*coop;
	float	*teamplay;
	float	*serverflags;
	float	*total_secrets;
	float	*total_monsters;
	float	*found_secrets;
	float	*killed_monsters;
	vec3_t	*v_forward;
	vec3_t	*v_up;
	vec3_t	*v_right;
	float	*trace_allsolid;
	float	*trace_startsolid;
	float	*trace_fraction;
	float	*trace_surfaceflags;
	float	*trace_endcontents;
	vec3_t	*trace_endpos;
	vec3_t	*trace_plane_normal;
	float	*trace_plane_dist;
	int	*trace_ent;
	float	*trace_inopen;
	float	*trace_inwater;
	int	*msg_entity;
	func_t	*main;
	func_t	*StartFrame;
	func_t	*PlayerPreThink;
	func_t	*PlayerPostThink;
	func_t	*ClientKill;
	func_t	*ClientConnect;
	func_t	*PutClientInServer;
	func_t	*ClientDisconnect;
	func_t	*SetNewParms;
	func_t	*SetChangeParms;
	float *cycle_wrapped;
	float *dimension_send;

	float *physics_mode;
	float *clientcommandframe;
	float *input_timelength;
	float *input_impulse;
	vec3_t *input_angles;
	vec3_t *input_movevalues;
	float *input_buttons;
	float *spawnparamglobals[NUM_SPAWN_PARMS];
} globalptrs_t;

#define P_VEC(v) (pr_global_struct->v)


/*my hands are tied when it comes to the layout of this structure
On the server side, the structure *must* match original quakeworld, or we break compatibility with mvdsv's qvm api
On the client, it really doesn't matter what order fields are in, qclib will remap.
But fields that are actually useful on both sides need to be in the same locations.
But if we include all, that's a waste for csqc...
But we can overlap useful csqc-only ones with ssqc ones that are not going to be used on the client, so long as the types match.
This list isn't shared with the menu.

so the base fields are a fixed size
and the extension fields are added on the end and can have extra vm-specific stuff added on the end
*/
/*DO NOT ADD TO THIS STRUCTURE (base-qw-compat for q1qvm)*/
#define comqcfields	\
	comfieldfloat(modelindex,NULL)\
	comfieldvector(absmin,NULL)\
	comfieldvector(absmax,NULL)\
	comfieldfloat(ltime,NULL)\
	comfieldfloat(lastruntime,NULL)	/*type doesn't match the qc, we use a hidden double instead. this is dead.*/ 	\
	comfieldfloat(movetype,NULL)\
	comfieldfloat(solid,NULL)\
	comfieldvector(origin,NULL)\
	comfieldvector(oldorigin,NULL)\
	comfieldvector(velocity,NULL)\
	comfieldvector(angles,NULL)\
	comfieldvector(avelocity,NULL)\
	comfieldstring(classname,NULL)\
	comfieldstring(model,NULL)\
	comfieldfloat(frame,NULL)\
	comfieldfloat(skin,NULL)\
	comfieldfloat(effects,NULL)\
	comfieldvector(mins,NULL)\
	comfieldvector(maxs,NULL)\
	comfieldvector(size,NULL)\
	comfieldfunction(touch, ".void()",NULL)\
	comfieldfunction(use, ".void()",NULL)\
	comfieldfunction(think, ".void()",NULL)\
	comfieldfunction(blocked, ".void()",NULL)\
	comfieldfloat(nextthink,NULL)\
	comfieldentity(groundentity,NULL)\
	comfieldfloat(health,NULL)\
	comfieldfloat(frags,NULL)\
	comfieldfloat(weapon,NULL)\
	comfieldstring(weaponmodel,NULL)\
	comfieldfloat(weaponframe,NULL)\
	comfieldfloat(currentammo,NULL)\
	comfieldfloat(ammo_shells,NULL)\
	comfieldfloat(ammo_nails,NULL)\
	comfieldfloat(ammo_rockets,NULL)\
	comfieldfloat(ammo_cells,NULL)\
	comfieldfloat(items,NULL)\
	comfieldfloat(takedamage,NULL)\
	comfieldentity(chain,NULL)\
	comfieldfloat(deadflag,NULL)\
	comfieldvector(view_ofs,NULL)\
	comfieldfloat(button0,NULL)\
	comfieldfloat(button1,NULL)	/*dead field in nq mode*/	\
	comfieldfloat(button2,NULL)\
	comfieldfloat(impulse,NULL)\
	comfieldfloat(fixangle,NULL)\
	comfieldvector(v_angle,NULL)\
	comfieldstring(netname,NULL)\
	comfieldentity(enemy,NULL)\
	comfieldfloat(flags,NULL)\
	comfieldfloat(colormap,NULL)\
	comfieldfloat(team,NULL)\
	comfieldfloat(max_health,NULL)\
	comfieldfloat(teleport_time,NULL)\
	comfieldfloat(armortype,NULL)\
	comfieldfloat(armorvalue,NULL)\
	comfieldfloat(waterlevel,NULL)\
	comfieldfloat(watertype,NULL)\
	comfieldfloat(ideal_yaw,NULL)\
	comfieldfloat(yaw_speed,NULL)\
	comfieldentity(aiment,NULL)\
	comfieldentity(goalentity,NULL)\
	comfieldfloat(spawnflags,NULL)\
	comfieldstring(target,NULL)\
	comfieldstring(targetname,NULL)\
	comfieldfloat(dmg_take,NULL)\
	comfieldfloat(dmg_save,NULL)\
	comfieldentity(dmg_inflictor,NULL)\
	comfieldentity(owner,NULL)\
	comfieldvector(movedir,NULL)\
	comfieldstring(message,NULL)	/*don't use directly, hexen2 uses floats, so we go via qclib for message*/\
	comfieldfloat(sounds,NULL)\
	comfieldstring(noise,NULL)\
	comfieldstring(noise1,NULL)\
	comfieldstring(noise2,NULL)\
	comfieldstring(noise3,NULL)
/*DO NOT ADD TO THE ABOVE STRUCTURE*/

#define comextqcfields	\
	comfieldvector(punchangle,NULL) /*std in nq*/\
	comfieldfloat(gravity,NULL)	/*added in quake 1.09 (for hipnotic)*/\
	comfieldfloat(hull,NULL)/*PEXT_HEXEN2*/\
	comfieldentity(movechain,NULL)/*hexen2*/\
	comfieldfunction(chainmoved, ".void()",NULL)/*hexen2*/\
	comfieldfunction(contentstransition, ".void(float old, float new)",NULL)/*ENTITYCONTENTSTRANSITION*/\
	comfieldfloat(dimension_solid,NULL)/*EXT_DIMENSION_PHYSICS*/\
	comfieldfloat(dimension_hit,NULL)/*EXT_DIMENSION_PHYSICS*/\
	comfieldfloat(hitcontentsmask,NULL)\
	comfieldfloat(scale,NULL)/*DP_ENT_SCALE*/\
	comfieldfloat(fatness,NULL)/*FTE_PEXT_FATNESS*/\
	comfieldfloat(alpha,NULL)/*DP_ENT_ALPHA*/\
	comfieldentity(tag_entity,NULL)\
	comfieldfloat(tag_index,NULL)\
	comfieldfloat(skeletonindex,NULL)		/*FTE_CSQC_SKELETONOBJECTS*/\
	comfieldvector(colormod,NULL)\
	comfieldvector(glowmod,NULL)\
	comfieldvector(gravitydir,NULL)\
	comfieldfunction(camera_transform,".vector(vector org, vector ang)", NULL)\
	comfieldfloat(pmove_flags,NULL)/*EXT_CSQC_1*/\
	comfieldfloat(friction,NULL)/*DP_...PHYSICS*/\
	comfieldfloat(erp,NULL)/*DP_...PHYSICS*/\
	comfieldfloat(jointtype,NULL)/*DP_...PHYSICS*/\
	comfieldfloat(mass,NULL)/*DP_...PHYSICS*/\
	comfieldfloat(bouncefactor,NULL)/*DP_...PHYSICS*/\
	comfieldfloat(bouncestop,NULL)/*DP_...PHYSICS*/

#define svextqcfields \
	comfieldfloat(maxspeed,NULL)/*added in quake 1.09*/\
	comfieldfloat(items2,NULL)		/*added in quake 1.09 (for hipnotic)*/\
	comfieldentity(view2,NULL)/*FTE_PEXT_VIEW2*/\
	comfieldvector(movement,NULL)\
	comfieldfloat(vw_index,NULL)\
	comfieldentity(nodrawtoclient,NULL)\
	comfieldentity(drawonlytoclient,NULL)\
	comfieldentity(viewmodelforclient,NULL)/*DP_ENT_VIEWMODEL*/\
	comfieldentity(exteriormodeltoclient,NULL)\
	comfieldfloat(button3,"DP_INPUTBUTTONS (note in qw, we set 1 to equal 3, to match zquake/fuhquake/mvdsv)")\
	comfieldfloat(button4,NULL)\
	comfieldfloat(button5,NULL)\
	comfieldfloat(button6,NULL)\
	comfieldfloat(button7,NULL)\
	comfieldfloat(button8,NULL)\
	comfieldfloat(viewzoom,NULL)/*DP_VIEWZOOM*/\
	comfieldfloat(glow_size,NULL)\
	comfieldfloat(glow_color,NULL)\
	comfieldfloat(glow_trail,NULL)\
	comfieldfloat(traileffectnum,NULL)/*DP_ENT_TRAILEFFECTNUM*/\
	comfieldvector(color,NULL)/*Hexen2 has a .float color, the warnings should be benign*/ \
	comfieldfloat(light_lev,NULL)\
	comfieldfloat(style,NULL)\
	comfieldfloat(pflags,NULL)\
	comfieldfloat(clientcolors,NULL)\
	comfieldfloat(dimension_see,NULL)/*EXT_DIMENSION_VISIBLE*/\
	comfieldfloat(dimension_seen,NULL)/*EXT_DIMENSION_VISIBLE*/\
	comfieldfloat(dimension_ghost,NULL)/*EXT_DIMENSION_GHOST*/\
	comfieldfloat(dimension_ghost_alpha,NULL)/*EXT_DIMENSION_GHOST*/\
	comfieldfloat(playerclass,NULL)/*hexen2 requirements*/\
	comfieldfloat(drawflags,NULL)/*hexen2*/\
	comfieldfloat(hasted,NULL)/*hexen2 uses this AS WELL as maxspeed*/\
	comfieldfloat(light_level,NULL)/*hexen2's grabbing light level from client*/\
	comfieldfloat(abslight,NULL)/*hexen2's force a lightlevel*/\
	comfieldfunction(SendEntity, ".float(entity playerent, float changedflags)",NULL)/*EXT_CSQC*/\
	comfieldfloat(SendFlags,NULL)/*EXT_CSQC_1 (one of the DP guys came up with it)*/\
	comfieldfloat(Version,NULL)/*EXT_CSQC (obsolete)*/\
	comfieldfloat(pvsflags,NULL)/*EXT_CSQC_1*/\
	comfieldfloat(modelflags,NULL)\
	comfieldfloat(uniquespawnid,NULL)/*FTE_ENT_UNIQUESPAWNID*/\
	comfieldfunction(customizeentityforclient, ".float()",NULL)

//this is the list for all the csqc fields.
//(the #define is so the list always matches the ones pulled out)
#define csqcextfields	\
	comfieldfloat(entnum,NULL)		\
	comfieldfloat(frame2,NULL)		/*EXT_CSQC_1*/\
	comfieldfloat(frame1time,NULL)	/*EXT_CSQC_1*/\
	comfieldfloat(frame2time,NULL)	/*EXT_CSQC_1*/\
	comfieldfloat(lerpfrac,NULL)	/*EXT_CSQC_1*/\
	comfieldfloat(renderflags,NULL)\
	comfieldfloat(forceshader,NULL)/*FTE_CSQC_SHADERS*/\
							\
	comfieldfloat(baseframe,NULL)	/*FTE_CSQC_BASEFRAME*/\
	comfieldfloat(baseframe2,NULL)	/*FTE_CSQC_BASEFRAME*/\
	comfieldfloat(baseframe1time,NULL)	/*FTE_CSQC_BASEFRAME*/\
	comfieldfloat(baseframe2time,NULL)	/*FTE_CSQC_BASEFRAME*/\
	comfieldfloat(baselerpfrac,NULL)	/*FTE_CSQC_BASEFRAME*/\
	comfieldfloat(basebone,NULL)	/*FTE_CSQC_BASEFRAME*/\
							\
  	comfieldfloat(bonecontrol1,NULL)	/*FTE_CSQC_HALFLIFE_MODELS*/\
	comfieldfloat(bonecontrol2,NULL)	/*FTE_CSQC_HALFLIFE_MODELS*/\
	comfieldfloat(bonecontrol3,NULL)	/*FTE_CSQC_HALFLIFE_MODELS*/\
	comfieldfloat(bonecontrol4,NULL)	/*FTE_CSQC_HALFLIFE_MODELS*/\
	comfieldfloat(bonecontrol5,NULL)	/*FTE_CSQC_HALFLIFE_MODELS*/\
	comfieldfloat(subblendfrac,NULL)	/*FTE_CSQC_HALFLIFE_MODELS*/\
	comfieldfloat(basesubblendfrac,NULL)	/*FTE_CSQC_HALFLIFE_MODELS+FTE_CSQC_BASEFRAME*/\
							\
	comfieldfloat(drawmask,NULL)	/*So that the qc can specify all rockets at once or all bannanas at once*/	\
	comfieldfunction(predraw, ".void()",NULL)	/*If present, is called just before it's drawn.*/	\
							\
	comfieldfloat(ideal_pitch,NULL)\
	comfieldfloat(pitch_speed,NULL)

typedef struct stdentvars_s //standard = standard for qw
{
#define comfieldfloat(sharedname,desc) float sharedname;
#define comfieldvector(sharedname,desc) vec3_t sharedname;
#define comfieldentity(sharedname,desc) int sharedname;
#define comfieldstring(sharedname,desc) string_t sharedname;
#define comfieldfunction(sharedname, typestr,desc) func_t sharedname;
comqcfields
#undef comfieldfloat
#undef comfieldvector
#undef comfieldentity
#undef comfieldstring
#undef comfieldfunction
#ifdef VM_Q1
} stdentvars_t;

typedef struct extentvars_s
{
#endif
#define comfieldfloat(name,desc) float name;
#define comfieldvector(name,desc) vec3_t name;
#define comfieldentity(name,desc) int name;
#define comfieldstring(name,desc) string_t name;
#define comfieldfunction(name, typestr,desc) func_t name;
comextqcfields
svextqcfields
#undef comfieldfloat
#undef comfieldvector
#undef comfieldentity
#undef comfieldstring
#undef comfieldfunction

#ifdef VM_Q1
} extentvars_t;
#else
} stdentvars_t;
#endif

typedef struct {
#define comfieldfloat(sharedname,desc) float sharedname;
#define comfieldvector(sharedname,desc) vec3_t sharedname;
#define comfieldentity(sharedname,desc) int sharedname;
#define comfieldstring(sharedname,desc) string_t sharedname;
#define comfieldfunction(sharedname, typestr,desc) func_t sharedname;
comqcfields
#undef comfieldfloat
#undef comfieldvector
#undef comfieldentity
#undef comfieldstring
#undef comfieldfunction

#ifdef VM_Q1
} comentvars_t;
typedef struct {
#endif

#define comfieldfloat(name,desc) float name;
#define comfieldvector(name,desc) vec3_t name;
#define comfieldentity(name,desc) int name;
#define comfieldstring(name,desc) string_t name;
#define comfieldfunction(name, typestr,desc) func_t name;
comextqcfields
#undef comfieldfloat
#undef comfieldvector
#undef comfieldentity
#undef comfieldstring
#undef comfieldfunction

#ifdef VM_Q1
} comextentvars_t;
#else
} comentvars_t;
#endif

#ifdef USEODE
typedef struct
{
	void *ode_body;
	void *ode_geom;
} odebody_t;
typedef struct
{
	//doll info
	char name[32];
	int bone;
	float animate;
	qboolean draw:1;
	qboolean orient:1;
	int orientpeer;

	//ode info
	int shape;
	vec3_t dimensions;
	float mass;
} odebodyinfo_t;

typedef struct
{
	void *ode_joint;
} odejoint_t;
typedef struct
{
	//doll info
	char name[32];
//	unsigned int disablebits;
	qboolean draw:1;

	//ode info
	int type;
	int body1;	//handled by the ragdoll code, rather than the physics library.
	int body2;	//handled by the ragdoll code.
	int bonepivot;	//pivot is specified relative to this bone.

	float FMax,		FMax2;
	float HiStop,	HiStop2;
	float LoStop,	LoStop2;
	float CFM,		CFM2;
	float ERP,		ERP2;
	float Vel,		Vel2;
	vec3_t offset,	offset2;
	vec3_t axis,	axis2;
} odejointinfo_t;

typedef struct
{
	// physics parameters
	qboolean ode_physics;
	void *ode_body;
	void *ode_geom;
	void *ode_joint;
	float *ode_vertex3f;
	int *ode_element3i;
	int ode_numvertices;
	int ode_numtriangles;
	vec3_t ode_mins;
	vec3_t ode_maxs;
	vec_t ode_mass;
	vec3_t ode_origin;
	vec3_t ode_velocity;
	vec3_t ode_angles;
	vec3_t ode_avelocity;
	qboolean ode_gravity;
	int ode_modelindex;
	vec_t ode_movelimit; // smallest component of (maxs[]-mins[])
	float ode_offsetmatrix[16];
	float ode_offsetimatrix[16];
	int ode_joint_type;
	int ode_joint_enemy;
	int ode_joint_aiment;
	vec3_t ode_joint_origin; // joint anchor
	vec3_t ode_joint_angles; // joint axis
	vec3_t ode_joint_velocity; // second joint axis
	vec3_t ode_joint_movedir; // parameters
	void *ode_massbuf;
} entityode_t;
/*
typedef struct
{
	void *ode_body;
} skelbodyode_t;
typedef struct
{
	int dummy;
} skeljointode_t;
*/
typedef struct
{
	// for ODE physics engine
	qboolean ode; // if true then ode is activated
	qboolean hasodeents; // if true then we have some ode body somewhere, and we consume more cycles processing full physics, instead of trying to skip as much as we can
	qboolean hasextraobjs;
	void *ode_world;
	void *ode_space;
	void *ode_contactgroup;
	// number of constraint solver iterations to use (for dWorldStepFast)
	int ode_iterations;
	// actual step (server frametime / ode_iterations)
	vec_t ode_step;
	// max velocity for a 1-unit radius object at current step to prevent
	// missed collisions
	vec_t ode_movelimit;
} worldode_t;
#endif
