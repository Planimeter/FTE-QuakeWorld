//Config for Crosshairs
//crosshairs can be altered or added by editing only this file

//winquake calls this every frame.
//gl calls when changed or animating (that's the diference in animated and non animated)

//don't use a point more than 8 units away from the centre.
//default must be non animated

#ifdef NUMCROSSHAIRS

//case 0 is no cursor
//case 1 is the console text '+'
//neither use this file.

case 2:
	Pix(0 - 1, 0, c);
	Pix(0 - 3, 0, c2);
	Pix(0 + 1, 0, c);
	Pix(0 + 3, 0, c2);
	Pix(0, 0 - 1, c);
	Pix(0, 0 - 3, c2);
	Pix(0, 0 + 1, c);
	Pix(0, 0 + 3, c2);
	break;

case 3:
	Pix(0 - 1, 0, c);
	Pix(0 - 2, 0, c2);
	Pix(0 + 1, 0, c);
	Pix(0 + 2, 0, c2);
	Pix(0, 0 - 1, c);
	Pix(0, 0 - 2, c2);
	Pix(0, 0 + 1, c);
	Pix(0, 0 + 2, c2);
	break;

case 4:
	Pix(0-1, 0-1, c);
	Pix(0-2, 0-2, c2);
	Pix(0+1, 0+1, c);
	Pix(0+2, 0+2, c2);
	Pix(0-1, 0+1, c);
	Pix(0-2, 0+2, c2);
	Pix(0+1, 0-1, c);
	Pix(0+2, 0-2, c2);
	break;

case 5:
	Pix(0-1, 0-1, c);
	Pix(0-3, 0-3, c2);
	Pix(0+1, 0+1, c);
	Pix(0+3, 0+3, c2);
	Pix(0-1, 0+1, c);
	Pix(0-3, 0+3, c2);
	Pix(0+1, 0-1, c);
	Pix(0+3, 0-3, c2);
	break;

case 6:
	Pix(0-1, 0-2, c2);
	Pix(0+1, 0-2, c2);
	Pix(0-1, 0+2, c2);
	Pix(0+1, 0+2, c2);
	Pix(0-2, 0+1, c);
	Pix(0-2, 0-1, c);
	Pix(0+2, 0+1, c);
	Pix(0+2, 0-1, c);
	break;

case 7:
	Pix(0  , 0+2, c);
	Pix(0+1, 0+1, c2);
	Pix(0+2, 0  , c);
	Pix(0+1, 0-1, c2);
	Pix(0  , 0-2, c);
	Pix(0-1, 0-1, c2);
	Pix(0-2, 0  , c);
	Pix(0-1, 0+1, c2);
	break;

case 8:
	Pix(0  , 0+2, c);
	Pix(0  , 0-2, c);
	Pix(0+2, 0  , c2);
	Pix(0-2, 0  , c2);		
	break;

case 9:
	Pix(0  , 0-1, c);
	Pix(0-2, 0+1, c2);
	Pix(0+2, 0+1, c2);	
	break;

case 10:
	Pix(0  , 0-3, c);
	Pix(0-2, 0-2, c2);
	Pix(0  , 0-2, c);
	Pix(0+2, 0-2, c2);	
	Pix(0-3, 0  , c);
	Pix(0-2, 0  , c);
	Pix(0+2, 0  , c);
	Pix(0+3, 0  , c);
	Pix(0  , 0+3, c);
	Pix(0-2, 0+2, c2);
	Pix(0  , 0+2, c);
	Pix(0+2, 0+2, c2);
	break;

case 11:
	Pix(0-3, 0-3, c2);
	Pix(0  , 0-3, c);
	Pix(0+3, 0-3, c2);
	Pix(0-2, 0-2, c2);
	Pix(0  , 0-2, c);
	Pix(0+2, 0-2, c2);	
	Pix(0-3, 0  , c);
	Pix(0-2, 0  , c);
	Pix(0+2, 0  , c);
	Pix(0+3, 0  , c);
	Pix(0  , 0+3, c);
	Pix(0-2, 0+2, c2);
	Pix(0  , 0+2, c);
	Pix(0-3, 0+3, c2);
	Pix(0+2, 0+2, c2);
	Pix(0+3, 0+3, c2);
	break;

case 12:
	Pix(0-4, 0  , c2);
	Pix(0-3, 0  , c2);
	Pix(0-2, 0  , c);
	Pix(0-1, 0  , c);
	Pix(0+1, 0  , c);
	Pix(0+2, 0  , c);	
	Pix(0+3, 0  , c2);
	Pix(0+4, 0  , c2);		
	break;

case 13:
	Pix(0  , 0-4, c2);
	Pix(0  , 0-3, c2);
	Pix(0  , 0-2, c);
	Pix(0  , 0-1, c);
	Pix(0  , 0+1, c);
	Pix(0  , 0+2, c);	
	Pix(0  , 0+3, c2);
	Pix(0  , 0+4, c2);		
	break;

case 14:
	Pix(0-4, 0  , c2);
	Pix(0-3, 0  , c2);
	Pix(0-2, 0  , c);
	Pix(0-1, 0  , c);
	Pix(0+1, 0  , c);
	Pix(0+2, 0  , c);	
	Pix(0+3, 0  , c2);
	Pix(0+4, 0  , c2);		

	Pix(0  , 0-4, c2);
	Pix(0  , 0-3, c2);
	Pix(0  , 0-2, c);
	Pix(0  , 0-1, c);
	Pix(0  , 0+1, c);
	Pix(0  , 0+2, c);	
	Pix(0  , 0+3, c2);
	Pix(0  , 0+4, c2);
	break;

case 15:
	Pix(0  , 0-4, c);
	Pix(0-3, 0-3, c2);
	Pix(0  , 0-3, c);
	Pix(0+3, 0-3, c2);
	Pix(0-2, 0-2, c2);
	Pix(0  , 0-2, c);
	Pix(0+2, 0-2, c2);	
	Pix(0-4, 0  , c);
	Pix(0-3, 0  , c);
	Pix(0-2, 0  , c);
	Pix(0+2, 0  , c);
	Pix(0+3, 0  , c);
	Pix(0+4, 0  , c);
	Pix(0  , 0+3, c);
	Pix(0-2, 0+2, c2);
	Pix(0  , 0+2, c);
	Pix(0-3, 0+3, c2);
	Pix(0+2, 0+2, c2);
	Pix(0+3, 0+3, c2);
	Pix(0  , 0+4, c);
	break;

case 16:
	Pix(0  , 0  , c2);
	Pix(0+1, 0+1, c);
	break;

case 17:
	Pix(0 , 0 , c);
	Pix(0 ,  1, c2);
	Pix(0 ,  2, c2);
	Pix( 1,  3, c);
	Pix( 1, 0 , c2);
	Pix( 2, 0 , c2);
	Pix( 3,  1, c);
	break;

case 18:
	Pix(0 , 0 , c);
	Pix(-2, 0 , c2);
	Pix(-3, 0 , c2);
	Pix( 2, 0 , c2);
	Pix( 3, 0 , c2);
	Pix(-3, 1 , c2);
	Pix( 3, 1 , c2);
	Pix(-3, 2 , c2);
	Pix( 3, 2 , c2);
	Pix(-2, 2 , c2);
	Pix( 2, 2 , c2);
	Pix(-2, 3 , c2);
	Pix( 2, 3 , c2);
	Pix(-1, 3 , c2);
	Pix( 1, 3 , c2);
	Pix( 0, 3 , c2);
	Pix( 0, 4 , c2);
	break;

case 19:	//tripointer
	Pix(0 , -1, c);	//north
	Pix(0 , -2, c);
	Pix(0 , -3, c);

	Pix(1 , 1 , c);
	Pix(2 , 2 , c);//east
	Pix(3 , 3 , c);

	Pix(-1, 1 , c);//west
	Pix(-2, 2 , c);
	Pix(-3, 3 , c);
	
	break;

case 20:	//twin circles
	{
	#define DEG(a) (a * (3.14 / 180))
	#define SCLE 8	//don't let it get bigger than 16 wide (+-8)
	#define SCLE2 4

		int a;
		#ifndef GLQUAKE
		for (a = 0; a < 360; a+=5)	//softquake doesn't draw as many pixels.
		#else
		for (a = 0; a < 360; a+=1)	//glquake gets high precision - done less, ya see
		#endif
		{
			Pix((int)(sin(DEG(a)) * SCLE ), (int)(cos(DEG(a)) * SCLE ) , c );
			Pix((int)(cos(DEG(a)) * SCLE2), (int)(sin(DEG(a)) * SCLE2) , c2);
		}

	#undef SCLE
	}
break;

#else
//what's the next?
#define FIRSTANIMATEDCROSHAIR 21
#endif
#ifdef NUMCROSSHAIRS

case FIRSTANIMATEDCROSHAIR:	//spinners
{
	#define DEG(a) (a * (3.14 / 180))
	#define SPEED 6
	#define SCLE 8	//don't let it get bigger than 16 wide (+-8)
	#define SCLE2 4
	#define TIMER realtime
	Pix((int)(sin(TIMER*SPEED         ) * SCLE ), (int)(cos(TIMER*SPEED         ) * SCLE ) , c );
	Pix((int)(sin(TIMER*SPEED+DEG(90 )) * SCLE ), (int)(cos(TIMER*SPEED+DEG(90 )) * SCLE ) , c );
	Pix((int)(sin(TIMER*SPEED+DEG(180)) * SCLE ), (int)(cos(TIMER*SPEED+DEG(180)) * SCLE ) , c );	
	Pix((int)(sin(TIMER*SPEED+DEG(270)) * SCLE ), (int)(cos(TIMER*SPEED+DEG(270)) * SCLE ) , c );

	Pix((int)(cos(TIMER*SPEED         ) * SCLE2), (int)(sin(TIMER*SPEED         ) * SCLE2) , c2);
	Pix((int)(cos(TIMER*SPEED+DEG(90 )) * SCLE2), (int)(sin(TIMER*SPEED+DEG(90 )) * SCLE2) , c2);
	Pix((int)(cos(TIMER*SPEED+DEG(180)) * SCLE2), (int)(sin(TIMER*SPEED+DEG(180)) * SCLE2) , c2);	
	Pix((int)(cos(TIMER*SPEED+DEG(270)) * SCLE2), (int)(sin(TIMER*SPEED+DEG(270)) * SCLE2) , c2);

	#undef SCLE
}
	break;

case (FIRSTANIMATEDCROSHAIR+1):
{
	#define DEG(a) (a * (3.14 / 180))
	#define SPEED 6
	#define SCLE 4	//don't let it get bigger than 16 wide (+-8)
	#define TIMER realtime
	
	Pix((int)(sin(TIMER*SPEED         ) * SCLE), (int)(sin(TIMER*SPEED         ) * -SCLE) , c );
	Pix((int)(sin(TIMER*SPEED+DEG(180)) * SCLE), (int)(sin(TIMER*SPEED+DEG(180)) * -SCLE) , c2);	

	Pix((int)(cos(TIMER*SPEED         ) * SCLE), (int)(cos(TIMER*SPEED         ) * SCLE ) , c );
	Pix((int)(cos(TIMER*SPEED+DEG(180)) * SCLE), (int)(cos(TIMER*SPEED+DEG(180)) * SCLE ) , c2);	

	#undef SCLE
	#undef SPEED
}
	break;

case (FIRSTANIMATEDCROSHAIR+2):
{
	#define DEG(a) (a * (3.14 / 180))
	#define SPEED 6
	#define SCLE 4	//don't let it get bigger than 16 wide (+-8)
	#define TIMER realtime
	
	Pix((int)(sin(TIMER*SPEED         ) * SCLE), (int)(sin(TIMER*SPEED         ) * -SCLE) , c );
	Pix((int)(sin(TIMER*SPEED+DEG(90)) * SCLE), (int)(sin(TIMER*SPEED+DEG(90)) * -SCLE) , c2);
	Pix((int)(sin(TIMER*SPEED+DEG(180)) * SCLE), (int)(sin(TIMER*SPEED+DEG(180)) * -SCLE) , c);
	Pix((int)(sin(TIMER*SPEED+DEG(270)) * SCLE), (int)(sin(TIMER*SPEED+DEG(270)) * -SCLE) , c2);

	Pix((int)(cos(TIMER*SPEED         ) * SCLE), (int)(cos(TIMER*SPEED         ) * SCLE ) , c );
	Pix((int)(sin(TIMER*SPEED+DEG(90)) * SCLE), (int)(sin(TIMER*SPEED+DEG(90)) * SCLE) , c2);
	Pix((int)(cos(TIMER*SPEED+DEG(180)) * SCLE), (int)(cos(TIMER*SPEED+DEG(180)) * SCLE ) , c);	
	Pix((int)(sin(TIMER*SPEED+DEG(270)) * SCLE), (int)(sin(TIMER*SPEED+DEG(270)) * SCLE) , c2);

	#undef SCLE
	#undef SPEED
}
	break;

case (FIRSTANIMATEDCROSHAIR+3):
{
	int a;
	#define DEG(a) (a * (3.14 / 180))
	#define SPEED 9
	#define SPEED2 4
	#define SIZE 8	//don't let it get bigger than 16 wide (+-8)
	#define SCLE 8
	#define TIMER realtime

	for (a = -SIZE; a < SIZE; a+=2)
	{
		Pix(a, (int)(sin(TIMER*SPEED2) * SCLE), c);
		Pix((int)(sin(TIMER*SPEED) * SCLE), a, c2);
	}

}
	break;
#else

//what did we reach
#define NUMCROSSHAIRS FIRSTANIMATEDCROSHAIR+3
#define CROSSHAIR_H

#endif
